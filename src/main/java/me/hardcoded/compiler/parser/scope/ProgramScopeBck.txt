package me.hardcoded.compiler.parser.scope;

import me.hardcoded.compiler.parser.expr.NameExpr;
import me.hardcoded.compiler.parser.type.Reference;
import me.hardcoded.lexer.Token;

import java.util.*;

// Priority ruesl
// Global is checked last
// Lables before functions in references
// Locals before all globals
// Locals before all globals when calls
// Only reference and call can get function pointers
// (&function) (function())
// You cannot get references from overloaded functions
// TODO: Keep a list of references that needs to be imported
public class ProgramScopeBck {
	private int count;
	private final LinkedList<SubScope> localScope;
	private final LinkedList<SubScope> scopes;
	private final Set<Reference> functions;
	
	public ProgramScopeBck() {
		this.scopes = new LinkedList<>();
		this.functions = new HashSet<>();
	}
	
	public void pushBlock() {
		scopes.add(new SubScope());
	}
	
	public void popBlock() {
		scopes.removeLast();
	}
	
	public Reference addFunc(String name) {
		// TODO: Overloading
		
		if (getFunc(name) != null) {
			return null;
		}
		
		Reference reference = new Reference(name, count++, 0);
		functions.add(reference);
		return reference;
	}
	
	public Reference getFunc(String name) {
		for (Reference ref : functions) {
			if (name.equals(ref.name)) {
				return ref;
			}
		}
		
		return null;
	}
	
	private SubScope getScope() {
		return scopes.getLast();
	}
	
	public void pushLocals() {
		getScope().locals.add(new Locals());
	}
	
	public void popLocals() {
		getScope().locals.removeLast();
	}
	
	public void pushLabels() {
		getScope().labels.add(new Labels());
	}
	
	public void popLabels() {
		getScope().labels.removeLast();
	}
	
	public Reference addLocal(String name) {
		return getScope().getLocals().addLocal(name);
	}
	
	public Reference getLocal(String name) {
		Iterator<Locals> iter = getScope().locals.descendingIterator();
		while (iter.hasNext()) {
			Reference reference = iter.next().getLocal(name);
			if (reference != null) {
				return reference;
			}
		}
		
		return null;
	}
	
	public Reference addLabel(String name) {
		return getScope().getLabels().addLabel(name);
	}
	
	public void addGoto(Token token) {
		getScope().getLabels().addGoto(token);
	}
	
	private class SubScope {
		private final LinkedList<Locals> locals;
		private final LinkedList<Labels> labels;
		
		public SubScope() {
			this.locals = new LinkedList<>();
			this.labels = new LinkedList<>();
		}
		
		public Locals getLocals() {
			return locals.getLast();
		}
		
		public Labels getLabels() {
			return labels.getLast();
		}
	}
	
	public class Locals {
		public final Map<String, Reference> locals;
		
		private Locals() {
			this.locals = new HashMap<>();
		}
		
		public Reference addLocal(String name) {
			if (locals.containsKey(name)) {
				return null;
			}
			
			Reference reference = new Reference(name, count++, 0);
			locals.put(name, reference);
			return reference;
		}
		
		public Reference getLocal(String name) {
			return locals.get(name);
		}
	}
	
	public class Labels {
		private final Map<String, Reference> definedLabels;
		private final List<Token> declaredGotos;
		private final List<NameExpr> missingReference;
		
		private Labels() {
			this.definedLabels = new HashMap<>();
			this.declaredGotos = new ArrayList<>();
			this.missingReference = new ArrayList<>();
		}
		
		public List<Token> getDeclaredGotos() {
			return declaredGotos;
		}
		
		public Set<String> getDefinedLabels() {
			return definedLabels.keySet();
		}
		
		public Reference getLabel(String name) {
			return definedLabels.get(name);
		}
		
		public Reference addLabel(String name) {
			if (definedLabels.containsKey(name)) {
				return null;
			}
			
			Reference reference = new Reference(name, count++, Reference.LABEL);
			definedLabels.put(name, reference);
			return reference;
		}
		
		public void addGoto(Token token) {
			declaredGotos.add(token);
		}
		
		public void addMissingReference(NameExpr expr) {
			missingReference.add(expr);
		}
		
		public List<NameExpr> getMissingReferences() {
			return missingReference;
		}
	}
}
